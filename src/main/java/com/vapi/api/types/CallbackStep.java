/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.vapi.api.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.vapi.api.core.ObjectMappers;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = CallbackStep.Builder.class)
public final class CallbackStep {
    private final Optional<CallbackStepBlock> block;

    private final Optional<List<AssignmentMutation>> mutations;

    private final String name;

    private final Optional<String> blockId;

    private final Optional<Map<String, Object>> input;

    private final Map<String, Object> additionalProperties;

    private CallbackStep(
            Optional<CallbackStepBlock> block,
            Optional<List<AssignmentMutation>> mutations,
            String name,
            Optional<String> blockId,
            Optional<Map<String, Object>> input,
            Map<String, Object> additionalProperties) {
        this.block = block;
        this.mutations = mutations;
        this.name = name;
        this.blockId = blockId;
        this.input = input;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return This is the block to use. To use an existing block, use <code>blockId</code>.
     */
    @JsonProperty("block")
    public Optional<CallbackStepBlock> getBlock() {
        return block;
    }

    /**
     * @return This is the mutations to apply to the context after the step is done.
     */
    @JsonProperty("mutations")
    public Optional<List<AssignmentMutation>> getMutations() {
        return mutations;
    }

    /**
     * @return This is the name of the step.
     */
    @JsonProperty("name")
    public String getName() {
        return name;
    }

    /**
     * @return This is the id of the block to use. To use a transient block, use <code>block</code>.
     */
    @JsonProperty("blockId")
    public Optional<String> getBlockId() {
        return blockId;
    }

    /**
     * @return This is the input to the block. You can use any key-value map as input to the block.
     * <p>Example:
     * {
     * &quot;name&quot;: &quot;John Doe&quot;,
     * &quot;age&quot;: 20
     * }</p>
     * <p>You can reference any variable in the context of the current block:</p>
     * <ul>
     * <li>&quot;{{your-step-name.output.your-property-name}}&quot; for another step's output (in the same workflow; read caveat #1)</li>
     * <li>&quot;{{your-step-name.input.your-property-name}}&quot; for another step's input (in the same workflow; read caveat #1)</li>
     * <li>&quot;{{your-block-name.output.your-property-name}}&quot; for another block's output (in the same workflow; read caveat #2)</li>
     * <li>&quot;{{your-block-name.input.your-property-name}}&quot; for another block's input (in the same workflow; read caveat #2)</li>
     * <li>&quot;{{workflow.input.your-property-name}}&quot; for the current workflow's input</li>
     * <li>&quot;{{global.your-property-name}}&quot; for the global context</li>
     * </ul>
     * <p>Example:
     * {
     * &quot;name&quot;: &quot;{{my-tool-call-step.output.name}}&quot;,
     * &quot;age&quot;: &quot;{{my-tool-call-step.input.age}}&quot;,
     * &quot;date&quot;: &quot;{{workflow.input.date}}&quot;
     * }</p>
     * <p>You can dynamically change the key name.</p>
     * <p>Example:
     * {
     * &quot;{{my-tool-call-step.output.key-name-for-name}}&quot;: &quot;{{name}}&quot;,
     * &quot;{{my-tool-call-step.input.key-name-for-age}}&quot;: &quot;{{age}}&quot;,
     * &quot;{{workflow.input.key-name-for-date}}&quot;: &quot;{{date}}&quot;
     * }</p>
     * <p>You can represent the value as a string, number, boolean, array, or object.</p>
     * <p>Example:
     * {
     * &quot;name&quot;: &quot;john&quot;,
     * &quot;age&quot;: 20,
     * &quot;date&quot;: &quot;2021-01-01&quot;,
     * &quot;metadata&quot;: {
     * &quot;unique-key&quot;: &quot;{{my-tool-call-step.output.unique-key}}&quot;
     * },
     * &quot;array&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],
     * }</p>
     * <p>Caveats:</p>
     * <ol>
     * <li>a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.</li>
     * <li>a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.</li>
     * </ol>
     */
    @JsonProperty("input")
    public Optional<Map<String, Object>> getInput() {
        return input;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof CallbackStep && equalTo((CallbackStep) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(CallbackStep other) {
        return block.equals(other.block)
                && mutations.equals(other.mutations)
                && name.equals(other.name)
                && blockId.equals(other.blockId)
                && input.equals(other.input);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.block, this.mutations, this.name, this.blockId, this.input);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static NameStage builder() {
        return new Builder();
    }

    public interface NameStage {
        _FinalStage name(@NotNull String name);

        Builder from(CallbackStep other);
    }

    public interface _FinalStage {
        CallbackStep build();

        _FinalStage block(Optional<CallbackStepBlock> block);

        _FinalStage block(CallbackStepBlock block);

        _FinalStage mutations(Optional<List<AssignmentMutation>> mutations);

        _FinalStage mutations(List<AssignmentMutation> mutations);

        _FinalStage blockId(Optional<String> blockId);

        _FinalStage blockId(String blockId);

        _FinalStage input(Optional<Map<String, Object>> input);

        _FinalStage input(Map<String, Object> input);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder implements NameStage, _FinalStage {
        private String name;

        private Optional<Map<String, Object>> input = Optional.empty();

        private Optional<String> blockId = Optional.empty();

        private Optional<List<AssignmentMutation>> mutations = Optional.empty();

        private Optional<CallbackStepBlock> block = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(CallbackStep other) {
            block(other.getBlock());
            mutations(other.getMutations());
            name(other.getName());
            blockId(other.getBlockId());
            input(other.getInput());
            return this;
        }

        /**
         * <p>This is the name of the step.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("name")
        public _FinalStage name(@NotNull String name) {
            this.name = Objects.requireNonNull(name, "name must not be null");
            return this;
        }

        /**
         * <p>This is the input to the block. You can use any key-value map as input to the block.</p>
         * <p>Example:
         * {
         * &quot;name&quot;: &quot;John Doe&quot;,
         * &quot;age&quot;: 20
         * }</p>
         * <p>You can reference any variable in the context of the current block:</p>
         * <ul>
         * <li>&quot;{{your-step-name.output.your-property-name}}&quot; for another step's output (in the same workflow; read caveat #1)</li>
         * <li>&quot;{{your-step-name.input.your-property-name}}&quot; for another step's input (in the same workflow; read caveat #1)</li>
         * <li>&quot;{{your-block-name.output.your-property-name}}&quot; for another block's output (in the same workflow; read caveat #2)</li>
         * <li>&quot;{{your-block-name.input.your-property-name}}&quot; for another block's input (in the same workflow; read caveat #2)</li>
         * <li>&quot;{{workflow.input.your-property-name}}&quot; for the current workflow's input</li>
         * <li>&quot;{{global.your-property-name}}&quot; for the global context</li>
         * </ul>
         * <p>Example:
         * {
         * &quot;name&quot;: &quot;{{my-tool-call-step.output.name}}&quot;,
         * &quot;age&quot;: &quot;{{my-tool-call-step.input.age}}&quot;,
         * &quot;date&quot;: &quot;{{workflow.input.date}}&quot;
         * }</p>
         * <p>You can dynamically change the key name.</p>
         * <p>Example:
         * {
         * &quot;{{my-tool-call-step.output.key-name-for-name}}&quot;: &quot;{{name}}&quot;,
         * &quot;{{my-tool-call-step.input.key-name-for-age}}&quot;: &quot;{{age}}&quot;,
         * &quot;{{workflow.input.key-name-for-date}}&quot;: &quot;{{date}}&quot;
         * }</p>
         * <p>You can represent the value as a string, number, boolean, array, or object.</p>
         * <p>Example:
         * {
         * &quot;name&quot;: &quot;john&quot;,
         * &quot;age&quot;: 20,
         * &quot;date&quot;: &quot;2021-01-01&quot;,
         * &quot;metadata&quot;: {
         * &quot;unique-key&quot;: &quot;{{my-tool-call-step.output.unique-key}}&quot;
         * },
         * &quot;array&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],
         * }</p>
         * <p>Caveats:</p>
         * <ol>
         * <li>a workflow can execute a step multiple times. example, if a loop is used in the graph. {{stepName.input/output.propertyName}} will reference the latest usage of the step.</li>
         * <li>a workflow can execute a block multiple times. example, if a step is called multiple times or if a block is used in multiple steps. {{blockName.input/output.propertyName}} will reference the latest usage of the block. this liquid variable is just provided for convenience when creating blocks outside of a workflow.</li>
         * </ol>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage input(Map<String, Object> input) {
            this.input = Optional.ofNullable(input);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "input", nulls = Nulls.SKIP)
        public _FinalStage input(Optional<Map<String, Object>> input) {
            this.input = input;
            return this;
        }

        /**
         * <p>This is the id of the block to use. To use a transient block, use <code>block</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage blockId(String blockId) {
            this.blockId = Optional.ofNullable(blockId);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "blockId", nulls = Nulls.SKIP)
        public _FinalStage blockId(Optional<String> blockId) {
            this.blockId = blockId;
            return this;
        }

        /**
         * <p>This is the mutations to apply to the context after the step is done.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage mutations(List<AssignmentMutation> mutations) {
            this.mutations = Optional.ofNullable(mutations);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "mutations", nulls = Nulls.SKIP)
        public _FinalStage mutations(Optional<List<AssignmentMutation>> mutations) {
            this.mutations = mutations;
            return this;
        }

        /**
         * <p>This is the block to use. To use an existing block, use <code>blockId</code>.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage block(CallbackStepBlock block) {
            this.block = Optional.ofNullable(block);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "block", nulls = Nulls.SKIP)
        public _FinalStage block(Optional<CallbackStepBlock> block) {
            this.block = block;
            return this;
        }

        @java.lang.Override
        public CallbackStep build() {
            return new CallbackStep(block, mutations, name, blockId, input, additionalProperties);
        }
    }
}
